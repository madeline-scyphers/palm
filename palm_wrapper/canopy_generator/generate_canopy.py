from __future__ import annotations

import numpy as np
import pandas as pd
import xarray as xr

from .canopy_types import ForestCanopy_data
from .utils import (
    Generate_PatchMap,
    get_stem_diam_and_breast_height,
    make_can_gen_rand_field,
)


def generate_canopy(domain: np.ndarray, zlad: np.ndarray = None, dz: float = 3, mean_lai: float | np.ndarray = 2):
    zlad = zlad if zlad is not None else np.arange(0, 8, 3)

    nx, ny, *_ = domain.shape
    # nx = 250 # #grid points east-west
    # ny = 250  # grid points south-north
    Dx = 5.0  # horizontal grid-mesh size [m]. LoadCanopy_Profiles.m assumes Dx==Dy, this can be easily modified
    Dy = Dx
    Dz = 3.0  # vertical grid-mesh size [m], needed to find the highest point in the canopy, in terms of # grid-points, which is sometimes used to dimensionalize input arrays in a program that might use this canopy

    # Landscape parameters:
    L = 10.0  # length-scale of discontinuity [m] that characterizes patch-type distribution (regioal lenght-scale)

    # patch params
    # PatchCutOff=np.array([0.9, 0.1]) # vector- portion of the area with each patch type -in this example; 90% Spring hardwood, 10% grass; Must total to 1!!!
    # patchtype=np.array([4, 2]) # patch type code to patch canopy properties data in ForestCanopy_data.m
    # # The user should add his/her patch types in ForestCanopy_data.m, as needed for their symulations and as observed in their environments

    PatchCutOff = np.array(
        [1]
    )  # vector- portion of the area with each patch type -in this example; 90% Spring hardwood, 10% grass; Must total to 1!!!
    patchtype = np.array([1])  # patch type code to patch canopy properties data in ForestCanopy_data.m
    # The user should add his/he

    # other params:
    filepath = "./OutFiles/"
    # path to location of output files`

    # Domain parameters:

    # *******************************************************************

    # Basic housekeeping
    # rand('state',sum(100*clock)); # randomize
    npatch = len(patchtype)
    # determine number of patch types

    # normalized PatchCutOff and convert to accumulated area
    PatchCutOff = PatchCutOff / sum(PatchCutOff)
    if npatch > 1:
        for p in range(1, npatch):  # p=2:npatch
            PatchCutOff[p] = PatchCutOff[p - 1] + PatchCutOff[p]

    # build meshed-grid
    x = np.arange(-(nx - 1) / 2, (nx - 1) / 2 + 1) * Dx
    y = np.arange(-(ny - 1) / 2, (ny - 1) / 2 + 1) * Dy
    X, Y = np.meshgrid(x, y, indexing="ij")

    StandDenc = np.zeros((npatch, 1))
    HDBHpar = np.zeros((npatch, 3))

    if npatch > 1:
        # Generate landscape map of patches
        AcF = np.exp(
            -(1 / L) * (X**2 + Y**2) ** 0.5
        )  # regional (patch level) autocorrelation function. Could be replaced by an observed auto-correlation function, or patch type map
        lambda_r = make_can_gen_rand_field(nx, ny, AcF, domain)
        patch = Generate_PatchMap(patchtype, lambda_r, nx, ny, PatchCutOff, npatch)

        # Allocate canopy properties params - These will be read by ForestCanopy_data
        avg_lai = np.zeros((npatch, 1))
        avgH = np.zeros((npatch, 1))
        sig_lai = np.zeros((npatch, 1))
        sigH = np.zeros((npatch, 1))
        avg_flux = np.zeros((npatch, 1))
        sig_flux = np.zeros((npatch, 1))
        avg_albedo = np.zeros((npatch, 1))
        sig_albedo = np.zeros((npatch, 1))
        bowen_ratio = np.zeros((npatch, 1))
        sig_bowen = np.zeros((npatch, 1))

        # Allocate canopy field variables - These are sets of fields with canopy properties per patch type. each fills the entire domains.
        # Each field will be cut and put together according to the landscape patch.
        #  each set of fields that are associated with one patch are covarying,
        #  and generated by normalization of a single, path level random filed
        #  (lambdap). The canopy properties params are used for these
        #  normalizations
        CSProf = np.zeros((npatch, 101))
        LAD = np.zeros((npatch, 101))
        AcF = np.zeros((nx, ny, npatch))
        lambdap = np.zeros((nx, ny, npatch))
        TotLAI = np.zeros((nx, ny, npatch))
        Height = np.zeros((nx, ny, npatch))
        Bowen = np.zeros((nx, ny, npatch))
        TotFlux = np.zeros((nx, ny, npatch))
        Albedo = np.zeros((nx, ny, npatch))

        # generate a random canopy field for each patch type
        for z in range(npatch):
            canopy = ForestCanopy_data(patchtype[z], nx, Dx, ny, Dy, mean_lai, zlad, dz)
            (
                CSProf[z, :],
                HDBHpar[z, :],
                LAD[z, :],
                zcm,
                avg_lai[z],
                avgH[z],
                sig_lai[z],
                sigH[z],
                avg_flux[z],
                sig_flux[z],
                avg_albedo[z],
                sig_albedo[z],
                bowen_ratio[z],
                sig_bowen[z],
                StandDenc[z],
                AcF[:, :, z],
            ) = canopy.export()
            # rand('state',sum(100*clock))  # randomize
            lambdap[:, :, z] = make_can_gen_rand_field(nx, ny, AcF[:, :, z], domain)

            # xvec=reshape(lambdap(:,:,z),[nx*ny 1]);
            std = np.nanstd(lambdap)
            mu = np.nanmean(lambdap)

            # scale by mean and std
            l_minus_mean = lambdap[:, :, z] - mu
            if std == 0:
                TotLAI[:, :, z] = np.maximum(0, (l_minus_mean + avg_lai[z]))
                Height[:, :, z] = np.maximum(0, (l_minus_mean + avgH[z]))

                Bowen[:, :, z] = np.maximum(0, (l_minus_mean + bowen_ratio[z]))
                TotFlux[:, :, z] = np.maximum(0, (l_minus_mean + avg_flux[z]))
                Albedo[:, :, z] = np.maximum(0, (l_minus_mean + avg_albedo[z]))
            else:
                TotLAI[:, :, z] = np.maximum(0, (l_minus_mean * (sig_lai[z] / std) + avg_lai[z]))
                Height[:, :, z] = np.maximum(0, (l_minus_mean * (sigH[z] / std) + avgH[z]))

                Bowen[:, :, z] = np.maximum(0, (l_minus_mean * (sig_bowen[z] / std) + bowen_ratio[z]))
                TotFlux[:, :, z] = np.maximum(0, (l_minus_mean * (sig_flux[z] / std) + avg_flux[z]))
                Albedo[:, :, z] = np.maximum(0, (l_minus_mean * (sig_albedo[z] / std) + avg_albedo[z]))

        # compose a combined canopy usiing landscape patch map
        TotLAIc = np.zeros((nx, ny))
        Heightc = np.zeros((nx, ny))

        Bowenc = np.zeros((nx, ny))
        TotFluxc = np.zeros((nx, ny))
        Albedoc = np.zeros((nx, ny))

        for xp in range(nx):
            for yp in range(ny):
                TotLAIc[yp, xp] = TotLAI[yp, xp, patch[yp, xp]]
                Heightc[yp, xp] = Height[yp, xp, patch[yp, xp]]
                Bowenc[yp, xp] = Bowen[yp, xp, patch[yp, xp]]
                TotFluxc[yp, xp] = TotFlux[yp, xp, patch[yp, xp]]
                Albedoc[yp, xp] = Albedo[yp, xp, patch[yp, xp]]

    else:
        patch = np.ones((nx, ny))
        canopy = ForestCanopy_data(patchtype[0], nx, Dx, ny, Dy, mean_lai, zlad, dz)
        StandDenc[0] = canopy.stand_density
        HDBHpar[0, :] = canopy.HDBHpar
        lambdap = make_can_gen_rand_field(nx, ny, canopy.AcF, domain)

        std = lambdap.std()
        mu = lambdap.mean()

        vert_lambdap = np.where(lambdap != 0, lambdap - mu + 1, 0)
        # re-scale by mean and variance
        total_lad = vert_lambdap[:, :, None] * canopy.lad[None, None, :]
        TotLAIc = np.maximum(0, ((lambdap - mu) * (canopy.sig_lai / std) + canopy.avg_lai))
        Heightc = np.maximum(0, ((lambdap - mu) * (canopy.sigH / std) + canopy.avgH))
        Bowenc = np.maximum(0, ((lambdap - mu) * (canopy.sig_bowen / std) + canopy.bowen_ratio))
        TotFluxc = np.maximum(0, ((lambdap - mu) * (canopy.sig_flux / std) + canopy.avg_flux))
        Albedoc = np.maximum(0, ((lambdap - mu) * (canopy.sig_albedo / std) + canopy.avg_albedo))

    DBHc = get_stem_diam_and_breast_height(patch, HDBHpar, Heightc, nx, Dx, ny, Dy, StandDenc, npatch)

    Hmax = Heightc.max()
    zRi = Hmax // Dz + 2  # number of vertical grid points in the canopy domain +1
    dims_pzRyx = [npatch, len(canopy.zcm), zRi, *TotLAIc.shape, 0.0]

    canopy.CSProfile = canopy.CSProfile.T
    canopy.LAD = canopy.LAD.T
    canopy.zcm = canopy.zcm.T

    ds = convert_to_xarray(
        TotLAIc,
        Heightc,
        patch,
        TotFluxc,
        DBHc,
        total_lad,
        x,
        y,
        zlad,
    )

    return ds


def convert_to_xarray(lai, height, patch, flux, DBHc, total_lad, x, y, zlad):
    lai_ = xr.DataArray(
        data=lai,
        dims=["x", "y"],
        coords=dict(
            x=x,
            y=y,
        ),
        attrs=dict(
            long_name="Total Lai",
            units="m^2 / m^2",
        ),
    )
    lad_ = xr.DataArray(
        data=total_lad.T,
        dims=["zlad", "y", "x"],
        coords=dict(
            zlad=zlad,
            y=y,
            x=x,
        ),
        attrs=dict(
            long_name="leaf area density",
            units="m2/m3",
        ),
    )
    height_ = xr.DataArray(
        data=height,
        dims=["x", "y"],
        coords=dict(
            x=x,
            y=y,
        ),
        attrs=dict(
            long_name="Total height",
            units="m",
        ),
    )
    patch_ = xr.DataArray(
        data=patch,
        dims=["x", "y"],
        coords=dict(
            x=x,
            y=y,
        ),
        attrs=dict(
            long_name="patch categories",
        ),
    )
    flux_ = xr.DataArray(
        data=flux,
        dims=["x", "y"],
        coords=dict(
            x=x,
            y=y,
        ),
        attrs=dict(long_name="Total flux"),
    )
    DBHc_ = xr.DataArray(
        data=DBHc,
        dims=["x", "y"],
        coords=dict(
            x=x,
            y=y,
        ),
        attrs=dict(
            long_name="Stem diameter and breast height",
            units="m",
        ),
    )
    ds = xr.Dataset(dict(lai=lai_, lad=lad_, height=height_, patch=patch_, flux=flux_, DBHc=DBHc_))
    return ds


if __name__ == "__main__":
    generate_canopy()
